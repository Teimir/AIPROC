Команды
LDR - загрузить данные в регистр LDR x y : Rx <= y || LDR x, Ссылка на данные(DATA1: 50) : Rx <= Данные по ссылке (50)
ADD - сложить регистры ADD x y : Rx <= Rx + Ry
SUB - вычесть регистры SUB x y : Rx <= Rx - Ry
MOV - скопировать первый регистр во второй MOV x y : Ry <= Rx
POP - получить в регистр данные из стека POP x : Rx <= STACK
PUSH - положить в стек данные из регистра PUSH x : STACK <= Rx
JMP - безусловный переход по адресу / метке JMP x : Переход по номеру || JMP x (LABEL START:) : Переход по метке(START)
JFZ - переход при регистр 1 равном 0 по адресу / метке Как и выше, только если Ry == 0
JFO - переход при регистр 1 равном 1 по адресу / метке Как и выше, только если Ry == 1
PRT - вывести значение регистра PRT x : Вывод регистра ХЫ || INOP (СТРОГО РЕКОМЕНДУЕТСЯ НЕ ИСПОЛЬЗОВАТЬ, но придётся)
HALT - остановка HALT  || INOP (СТРОГО РЕКОМЕНДУЕТСЯ НЕ ИСПОЛЬЗОВАТЬ, но придётся)
CMP - сравнить регистры, результат в регистр флагов CMP x y : Устанавливает флаги см. ФЛАГИ
GTF - получить во второй регистр значение из первого регистра GTF x y : Rx <= FLAGS[Rx]
IN - положить значение во второй регистр из внешнюю шину по адресу из первого регистра IN x y : Ry <= BUS[Rx]
OUT - положить значение из первого регистра во внешнюю шину по адресу из второго регистра OUT x y : BUS[Ry] <= Rx

Флаги 0 - 7
#CF - Carry flag ZF - Zero flag SF - Sign flag OF - Overflow flag IE - Interrupt enable flag TF - Trap flag, BL - BiggerLess, EL - Equal


Модуль озу работает по правилам
0 адрес - адрес в рам
1 адрес - данные 
2 адрес - 1 (чтение) 0 (запись)
3 адрес - 1 (активировать озу)
Соглашение по использованию шины
0-9 ОЗУ
10-19 ПЗУ
20-Конец остальное